# 兵智世界项目 - 前后端连接实现详解

## 📋 概述

本项目采用前后端分离的架构，前端使用原生HTML/CSS/JavaScript，后端使用Node.js + Express框架，数据库使用SQLite。前后端通过RESTful API进行数据交互。

## 🏗️ 架构设计

```
前端 (Frontend)                    后端 (Backend)
┌─────────────────┐                ┌─────────────────┐
│  HTML/CSS/JS    │   HTTP/HTTPS   │  Node.js        │
│  ├─ 页面展示     │ ◄─────────────► │  ├─ Express     │
│  ├─ 用户交互     │   RESTful API  │  ├─ 路由处理     │
│  ├─ 数据请求     │                │  ├─ 业务逻辑     │
│  └─ 状态管理     │                │  └─ 数据库操作   │
└─────────────────┘                └─────────────────┘
                                           │
                                           ▼
                                   ┌─────────────────┐
                                   │  SQLite 数据库   │
                                   │  ├─ 武器数据     │
                                   │  ├─ 用户数据     │
                                   │  ├─ 图片/视频    │
                                   │  └─ 统计数据     │
                                   └─────────────────┘
```

## 🔗 连接方式详解

### 1. HTTP请求方式

#### GET 请求 - 数据获取
```javascript
// 前端发起请求
const response = await fetch('http://localhost:3000/api/weapons');
const data = await response.json();

// 后端处理请求
router.get('/', async (req, res) => {
    try {
        const weapons = db.prepare('SELECT * FROM weapons').all();
        res.json({ success: true, data: weapons });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});
```

#### POST 请求 - 数据创建
```javascript
// 前端发送数据
const response = await fetch('http://localhost:3000/api/weapons', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'x-admin-user': 'true'
    },
    body: JSON.stringify({
        name: '新武器',
        type: '坦克',
        country: '中国'
    })
});

// 后端接收处理
router.post('/', async (req, res) => {
    try {
        const { name, type, country } = req.body;
        const stmt = db.prepare('INSERT INTO weapons (name, type, country) VALUES (?, ?, ?)');
        const result = stmt.run(name, type, country);
        res.json({ success: true, data: { id: result.lastInsertRowid } });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});
```

#### PUT 请求 - 数据更新
```javascript
// 前端更新数据
const response = await fetch(`http://localhost:3000/api/weapons/${weaponId}`, {
    method: 'PUT',
    headers: {
        'Content-Type': 'application/json',
        'x-admin-user': 'true'
    },
    body: JSON.stringify({
        description: '更新后的描述'
    })
});

// 后端处理更新
router.put('/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const { description } = req.body;
        const stmt = db.prepare('UPDATE weapons SET description = ? WHERE id = ?');
        stmt.run(description, id);
        res.json({ success: true, message: '更新成功' });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});
```

#### DELETE 请求 - 数据删除
```javascript
// 前端删除数据
const response = await fetch(`http://localhost:3000/api/weapons/${weaponId}`, {
    method: 'DELETE',
    headers: {
        'x-admin-user': 'true'
    }
});

// 后端处理删除
router.delete('/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const stmt = db.prepare('DELETE FROM weapons WHERE id = ?');
        const result = stmt.run(id);
        if (result.changes > 0) {
            res.json({ success: true, message: '删除成功' });
        } else {
            res.status(404).json({ success: false, message: '武器不存在' });
        }
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});
```

### 2. 文件上传处理

#### 图片上传
```javascript
// 前端文件上传
const formData = new FormData();
formData.append('image', fileInput.files[0]);
formData.append('description', '图片描述');

const response = await fetch(`http://localhost:3000/api/weapon-images/weapon/${weaponId}/upload`, {
    method: 'POST',
    body: formData
});

// 后端文件处理
const multer = require('multer');
const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, 'backend/uploads/weapons/');
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
        cb(null, 'weapon-' + uniqueSuffix + path.extname(file.originalname));
    }
});

const upload = multer({ storage: storage });

router.post('/weapon/:weaponId/upload', upload.single('image'), (req, res) => {
    // 处理上传的文件
    const file = req.file;
    // 保存文件信息到数据库
    // 返回响应
});
```

#### 视频上传
```javascript
// 前端视频上传
const formData = new FormData();
formData.append('video', videoInput.files[0]);

const response = await fetch(`http://localhost:3000/api/weapon-videos/weapon/${weaponId}/upload`, {
    method: 'POST',
    body: formData
});

// 后端视频处理（支持流式传输）
router.get('/file/:filename', (req, res) => {
    const filename = req.params.filename;
    const video = db.prepare('SELECT file_path, mime_type FROM weapon_videos WHERE filename = ?').get(filename);
    
    const stat = fs.statSync(video.file_path);
    const fileSize = stat.size;
    const range = req.headers.range;

    if (range) {
        // 支持视频流播放
        const parts = range.replace(/bytes=/, "").split("-");
        const start = parseInt(parts[0], 10);
        const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
        const chunksize = (end - start) + 1;
        const file = fs.createReadStream(video.file_path, { start, end });
        const head = {
            'Content-Range': `bytes ${start}-${end}/${fileSize}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': chunksize,
            'Content-Type': video.mime_type,
        };
        res.writeHead(206, head);
        file.pipe(res);
    }
});
```

## 🛠️ 核心技术实现

### 1. 跨域处理 (CORS)
```javascript
// 后端CORS配置
app.use(cors({
    origin: process.env.NODE_ENV === 'production' 
        ? ['http://localhost:3001'] 
        : true,
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'x-user-id', 'x-user-role', 'x-admin-user']
}));
```

### 2. 错误处理
```javascript
// 前端错误处理
async function apiRequest(url, options = {}) {
    try {
        const response = await fetch(url, options);
        const data = await response.json();
        
        if (!response.ok) {
            throw new Error(data.message || '请求失败');
        }
        
        return data;
    } catch (error) {
        console.error('API请求失败:', error);
        throw error;
    }
}

// 后端错误处理中间件
app.use((error, req, res, next) => {
    logger.error('全局错误处理:', {
        error: error.message,
        stack: error.stack,
        url: req.url,
        method: req.method
    });

    res.status(error.status || 500).json({
        success: false,
        message: process.env.NODE_ENV === 'production' 
            ? '服务器内部错误' 
            : error.message
    });
});
```

### 3. 数据验证
```javascript
// 前端数据验证
function validateWeaponData(data) {
    const errors = [];
    
    if (!data.name || data.name.trim().length === 0) {
        errors.push('武器名称不能为空');
    }
    
    if (!data.type || data.type.trim().length === 0) {
        errors.push('武器类型不能为空');
    }
    
    if (!data.country || data.country.trim().length === 0) {
        errors.push('生产国家不能为空');
    }
    
    return errors;
}

// 后端数据验证中间件
const validateWeapon = (req, res, next) => {
    const { name, type, country } = req.body;
    const errors = [];
    
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
        errors.push('武器名称必须是非空字符串');
    }
    
    if (!type || typeof type !== 'string' || type.trim().length === 0) {
        errors.push('武器类型必须是非空字符串');
    }
    
    if (!country || typeof country !== 'string' || country.trim().length === 0) {
        errors.push('生产国家必须是非空字符串');
    }
    
    if (errors.length > 0) {
        return res.status(400).json({
            success: false,
            message: '数据验证失败',
            errors: errors
        });
    }
    
    next();
};
```

### 4. 身份验证
```javascript
// 前端身份验证
function setAuthHeaders(headers = {}) {
    const token = localStorage.getItem('authToken');
    if (token) {
        headers['Authorization'] = `Bearer ${token}`;
    }
    return headers;
}

// 后端身份验证中间件
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({
            success: false,
            message: '访问令牌缺失'
        });
    }
    
    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({
                success: false,
                message: '访问令牌无效'
            });
        }
        req.user = user;
        next();
    });
};
```

## 📊 API端点总览

### 武器相关API
| 方法 | 端点 | 功能 | 参数 |
|------|------|------|------|
| GET | `/api/weapons` | 获取武器列表 | `limit`, `offset`, `type`, `country` |
| GET | `/api/weapons/:id` | 获取单个武器详情 | `id` |
| GET | `/api/weapons/search` | 搜索武器 | `q`, `limit`, `offset` |
| POST | `/api/weapons` | 创建新武器 | 武器数据对象 |
| PUT | `/api/weapons/:id` | 更新武器信息 | `id`, 更新数据 |
| DELETE | `/api/weapons/:id` | 删除武器 | `id` |

### 图片管理API
| 方法 | 端点 | 功能 | 参数 |
|------|------|------|------|
| GET | `/api/weapon-images/weapon/:weaponId` | 获取武器图片列表 | `weaponId` |
| POST | `/api/weapon-images/weapon/:weaponId/upload` | 上传武器图片 | `weaponId`, 图片文件 |
| GET | `/api/weapon-images/file/:filename` | 获取图片文件 | `filename` |
| PUT | `/api/weapon-images/:imageId` | 更新图片信息 | `imageId`, 更新数据 |
| DELETE | `/api/weapon-images/:imageId` | 删除图片 | `imageId` |

### 视频管理API
| 方法 | 端点 | 功能 | 参数 |
|------|------|------|------|
| GET | `/api/weapon-videos/weapon/:weaponId` | 获取武器视频列表 | `weaponId` |
| POST | `/api/weapon-videos/weapon/:weaponId/upload` | 上传武器视频 | `weaponId`, 视频文件 |
| GET | `/api/weapon-videos/file/:filename` | 获取视频文件流 | `filename` |
| PUT | `/api/weapon-videos/:videoId` | 更新视频信息 | `videoId`, 更新数据 |
| DELETE | `/api/weapon-videos/:videoId` | 删除视频 | `videoId` |

### 统计数据API
| 方法 | 端点 | 功能 | 参数 |
|------|------|------|------|
| GET | `/api/manufacturer-statistics` | 获取制造商统计 | 无 |
| GET | `/api/weapon-types` | 获取武器类型统计 | 无 |
| GET | `/api/weapon-countries` | 获取国家统计 | 无 |
| GET | `/api/manufacturers` | 获取制造商列表 | `limit`, `offset` |

## 🔄 数据流程图

```
用户操作 → 前端JavaScript → HTTP请求 → 后端路由 → 业务逻辑 → 数据库操作 → 响应数据 → 前端更新界面

具体示例：
1. 用户点击"获取武器列表"按钮
2. 前端调用 fetch('/api/weapons')
3. 后端接收请求，路由到 weapons.js
4. 执行 SQL 查询：SELECT * FROM weapons
5. 返回 JSON 格式数据
6. 前端接收数据并渲染到页面
```

## 🛡️ 安全措施

### 1. 输入验证
- 前端：基本格式验证
- 后端：严格的数据类型和格式验证
- 数据库：参数化查询防止SQL注入

### 2. 文件上传安全
```javascript
// 文件类型验证
const fileFilter = (req, file, cb) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
    if (allowedTypes.includes(file.mimetype)) {
        cb(null, true);
    } else {
        cb(new Error('不支持的文件类型'), false);
    }
};

// 文件大小限制
const upload = multer({ 
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB限制
    }
});
```

### 3. 访问控制
```javascript
// 管理员权限检查
const requireAdmin = (req, res, next) => {
    const isAdmin = req.headers['x-admin-user'] === 'true';
    if (!isAdmin) {
        return res.status(403).json({
            success: false,
            message: '需要管理员权限'
        });
    }
    next();
};
```

## 📈 性能优化

### 1. 数据分页
```javascript
// 前端分页请求
const loadWeapons = async (page = 1, limit = 20) => {
    const offset = (page - 1) * limit;
    const response = await fetch(`/api/weapons?limit=${limit}&offset=${offset}`);
    return response.json();
};

// 后端分页实现
router.get('/', (req, res) => {
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    
    const weapons = db.prepare(`
        SELECT * FROM weapons 
        ORDER BY created_at DESC 
        LIMIT ? OFFSET ?
    `).all(limit, offset);
    
    const total = db.prepare('SELECT COUNT(*) as count FROM weapons').get().count;
    
    res.json({
        success: true,
        data: weapons,
        pagination: {
            total,
            limit,
            offset,
            hasMore: offset + limit < total
        }
    });
});
```

### 2. 缓存策略
```javascript
// 前端缓存
const cache = new Map();

const getCachedData = async (key, fetchFunction, ttl = 300000) => {
    const cached = cache.get(key);
    if (cached && Date.now() - cached.timestamp < ttl) {
        return cached.data;
    }
    
    const data = await fetchFunction();
    cache.set(key, {
        data,
        timestamp: Date.now()
    });
    
    return data;
};
```

### 3. 图片优化
```javascript
// 图片压缩和缩略图生成
const sharp = require('sharp');

const processImage = async (inputPath, outputPath) => {
    await sharp(inputPath)
        .resize(800, 600, { fit: 'inside', withoutEnlargement: true })
        .jpeg({ quality: 85 })
        .toFile(outputPath);
        
    // 生成缩略图
    await sharp(inputPath)
        .resize(200, 150, { fit: 'cover' })
        .jpeg({ quality: 80 })
        .toFile(outputPath.replace('.jpg', '_thumb.jpg'));
};
```

## 🧪 测试方法

### 1. 使用测试页面
打开 `test-frontend-backend-connection.html` 进行全面的连接测试：
- 服务器状态检查
- API端点测试
- 数据CRUD操作
- 文件上传测试
- 统计数据获取

### 2. 手动API测试
```bash
# 测试服务器状态
curl http://localhost:3000/health

# 测试获取武器列表
curl http://localhost:3000/api/weapons

# 测试搜索功能
curl "http://localhost:3000/api/weapons/search?q=坦克"

# 测试创建武器
curl -X POST http://localhost:3000/api/weapons \
  -H "Content-Type: application/json" \
  -H "x-admin-user: true" \
  -d '{"name":"测试武器","type":"坦克","country":"中国"}'
```

### 3. 浏览器开发者工具
- Network标签：查看HTTP请求和响应
- Console标签：查看JavaScript错误和日志
- Application标签：检查本地存储和缓存

## 🚀 部署注意事项

### 1. 环境配置
```javascript
// 生产环境配置
const config = {
    server: {
        port: process.env.PORT || 3000,
        env: process.env.NODE_ENV || 'development'
    },
    cors: {
        origin: process.env.NODE_ENV === 'production' 
            ? ['https://yourdomain.com'] 
            : true
    },
    database: {
        path: process.env.DB_PATH || './data/military-knowledge.db'
    }
};
```

### 2. 静态文件服务
```javascript
// 生产环境静态文件配置
if (process.env.NODE_ENV === 'production') {
    app.use(express.static(path.join(__dirname, '../frontend/dist')));
    
    app.get('*', (req, res) => {
        res.sendFile(path.join(__dirname, '../frontend/dist/index.html'));
    });
}
```

## 📝 总结

本项目的前后端连接通过以下方式实现：

1. **RESTful API设计**：标准的HTTP方法和状态码
2. **JSON数据格式**：统一的请求和响应格式
3. **文件上传处理**：支持图片和视频的上传与流式传输
4. **错误处理机制**：完善的错误捕获和用户友好的错误信息
5. **安全措施**：输入验证、文件类型检查、访问控制
6. **性能优化**：分页、缓存、图片压缩等
7. **测试工具**：提供完整的测试页面和API测试方法

通过这种架构，前端可以灵活地与后端进行数据交互，实现了武器数据的完整管理功能，包括基本的CRUD操作、文件上传、搜索、统计等功能。
